/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <random>

juce::String enableTextFunction (const gin::Parameter&, float v)
{
    return v > 0.0f ? "On" : "Off";
}

juce::String durationTextFunction (const gin::Parameter&, float v)
{
    return gin::NoteDuration::getNoteDurations()[size_t (v)].getName();
}

//==============================================================================
static gin::ProcessorOptions createProcessorOptions()
{
    return gin::ProcessorOptions()
        .withMidiLearn();
}

DelayAudioProcessor::DelayAudioProcessor()
    : gin::Processor (false, createProcessorOptions())
{
    float mxd = float (gin::NoteDuration::getNoteDurations().size()) - 1.0f;

    sync  = addExtParam ("sync",  "Sync",      "", "",   {   0.0f,   1.0f, 1.0f, 1.0f},    0.0f, 0.0f, enableTextFunction);
    time  = addExtParam ("time",  "Delay",     "", "",   {   0.0f, 120.0f, 0.0f, 0.3f},    1.0f, 0.0f);
    beat  = addExtParam ("beat",  "Delay",     "", "",   {   0.0f,    mxd, 1.0f, 1.0f},   13.0f, 0.0f, durationTextFunction);
    fb    = addExtParam ("fb",    "Feedback",  "", "dB", {-100.0f,   0.0f, 0.0f, 5.0f},  -10.0f, 0.1f);
    cf    = addExtParam ("cf",    "Crossfeed", "", "dB", {-100.0f,   0.0f, 0.0f, 5.0f}, -100.0f, 0.1f);
    mix   = addExtParam ("mix",   "Mix",       "", "%",  {   0.0f, 100.0f, 0.0f, 1.0f},    0.0f, 0.1f);
    
    delay = addIntParam ("delay", "Delay",     "", "",   {   0.0f, 120.0f, 0.0f, 1.0f},    1.0f, {0.2f, gin::SmoothingType::eased});
    
    fb->conversionFunction  = [] (float in) { return juce::Decibels::decibelsToGain (in); };
    cf->conversionFunction  = [] (float in) { return juce::Decibels::decibelsToGain (in); };
    mix->conversionFunction = [] (float in) { return in / 100.0f; };

    for (int i = 0; i < BinaryData::namedResourceListSize; i++)
    {
        int sz = 0;
        if (auto data = BinaryData::getNamedResource (BinaryData::namedResourceList[i], sz))
            extractProgram (BinaryData::originalFilenames[i], juce::MemoryBlock (data, size_t (sz)));
    }

    init();
}

DelayAudioProcessor::~DelayAudioProcessor()
{
}

//==============================================================================
void DelayAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    gin::Processor::prepareToPlay (sampleRate, samplesPerBlock);
    
    stereoDelay.setSampleRate (sampleRate);
}

void DelayAudioProcessor::reset()
{
    gin::Processor::reset();
    
    stereoDelay.reset();
}

void DelayAudioProcessor::releaseResources()
{
}

void DelayAudioProcessor::updateInternalParams()
{
    if (sync->isOn())
    {
        auto& duration = gin::NoteDuration::getNoteDurations()[(size_t)beat->getUserValueInt()];
        delay->setUserValue (duration.toSeconds (getPlayHead()));
    }
    else
    {
        delay->setUserValue (time->getUserValue());
    }
}

void DelayAudioProcessor::processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer& midi)
{
    if (midiLearn)
        midiLearn->processBlock (midi, buffer.getNumSamples());

    updateInternalParams();

    int numSamples = buffer.getNumSamples();
    if (isSmoothing())
    {
        int pos = 0;
        
        while (pos < numSamples)
        {
            auto workBuffer = gin::sliceBuffer (buffer, pos, 1);
            
            stereoDelay.setParams (delay->getProcValue (1), mix->getProcValue (1),
                                   fb->getProcValue (1), cf->getProcValue (1));
            
            stereoDelay.process (workBuffer);
            
            pos++;
        }
    }
    else
    {
        stereoDelay.setParams (delay->getProcValue (numSamples), mix->getProcValue (numSamples),
                               fb->getProcValue (numSamples), cf->getProcValue (numSamples));
        
        stereoDelay.process (buffer);
    }
}

//==============================================================================
bool DelayAudioProcessor::hasEditor() const
{
    return true;
}

juce::AudioProcessorEditor* DelayAudioProcessor::createEditor()
{
    return new DelayAudioProcessorEditor (*this);
}

//==============================================================================
// This creates new instances of the plugin..
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new DelayAudioProcessor();
}

